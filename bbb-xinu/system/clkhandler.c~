/* clkhandler.c - clkhandler */

#include <xinu.h>

/*-----------------------------------------------------------------------
 * clkhandler - high level clock interrupt handler
 *-----------------------------------------------------------------------
 */

void handlearptimeout()
{
struct	arpentry  *arptr;	/* Ptr to ARP cache entry	*/
int deletedArpCount = 0;
intmask mask = disable();
int32 i = 0;

// Delete arp cache after 5 minutes
	for (i=0; i<ARP_SIZ; i++) {
		arptr = &arpcache[i];
		if((clktime-arptr->arp_entry_time) >= 5 && arptr->arstate != AR_FREE)
		{
			
			arptr->arstate = AR_FREE;
			arptr->arp_entry_time = clktime;
			deletedArpCount++;
		}		
	}
	
	if(deletedArpCount > 0)
	{
		kprintf("%d entries deleted from arp cache due to expiry, the cache will be reloaded.\n", deletedArpCount);
		
	}

	restore(mask);
}

void	clkhandler()
{

	static uint32 count1000 = 1000;	/* variable to count 1000ms */
	static uint32 count5 = 300000;
	volatile struct am335x_timer1ms *csrptr = 0x44E31000;
					/* Pointer to timer CSR	    */

	/* If there is no interrupt, return */

	if((csrptr->tisr & AM335X_TIMER1MS_TISR_OVF_IT_FLAG) == 0) {
		return;
	}

	/* Acknowledge the interrupt */

	csrptr->tisr = AM335X_TIMER1MS_TISR_OVF_IT_FLAG;

	/* Decrement 1000ms counter */

	count1000--;

	/* After 1 sec, increment clktime */

	count5--;

	if(count5 == 0)
	{
		count5000 = 300000;
		handlearptimeout();
	}

	if(count1000 == 0) {
		clktime++;
		count1000 = 1000;
	}

	/* check if sleep queue is empty */

	if(!isempty(sleepq)) {

		/* sleepq nonempty, decrement the key of */
		/* topmost process on sleepq		 */

		if((--queuetab[firstid(sleepq)].qkey) == 0) {

			wakeup();
		}
	}

	/* Decrement the preemption counter */
	/* Reschedule if necessary	    */

	if((--preempt) == 0) {
		preempt = QUANTUM;
		resched();
	}
}
